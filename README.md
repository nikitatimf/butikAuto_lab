# butikAuto_laba
## Project name: auto shop
## This project is a platform for selling cars. Users can connect with each other, view ads, and post them on the platform.
## Target audience: car owners and those who want to buy one
## Key features: Users can post ads, edit them, specify various parameters, sort ads by multiple factors, register and authorize

## Project structure: 
* Home 
* Settings
* Ad Panel
* Favorites
* Filter and sorting
* Authentication
*  Messages
*  Personal account

## Technology stack
## Frontend:
  * Liblary: React
  ### The choice of React as a UI development technology is driven by a combination of factors that make it not just a tool, but a fundamental standard of modern front-end development. First and foremost, it's based on a component-based architecture. The entire interface is broken down into independent, isolated blocks—components—that can be reused across different parts of the application. This not only speeds up development but also dramatically simplifies code maintenance: changes to one component are automatically replicated across all its uses.
  ### В основе высокой производительности React лежит концепция виртуального DOM. Вместо того чтобы напрямую и часто манипулировать реальным DOM-деревом браузера (что является самой медленной операцией в вебе), React создает его легковесную копию в памяти. При изменении данных библиотека вычисляет минимально необходимые изменения и применяет их к реальному DOM. Это обеспечивает высокую скорость работы даже в сложных динамических интерфейсах с большим количеством данных. Код при этом пишется в декларативном стиле, особенно с использованием JSX, когда разработчик просто описывает, как интерфейс должен выглядеть в каждом состоянии, а React берет на себя рутину по его обновлению.
  ### A critical advantage is the vast and mature ecosystem that has developed around React. There's a proven solution for every common task: React Router for navigation, Redux, MobX, or Zustand for managing complex state. Furthermore, the availability of next-level frameworks like Next.js allows for server-side rendering, which is critical for SEO and first-page load speed. And using React Native opens the door to native mobile development with the same knowledge base.
  * Router: React Router
  ### React Router was chosen as the navigation solution for a React app because it is the de facto standard and fits perfectly with the library's philosophy. Designed for a declarative approach, React Router allows you to describe navigation rules not as complex configuration files, but as part of the interface, using standard components. This feels natural to a React developer: routing here is simply another layer of the UI that renders when the browser URL matches the specified path.
  ### The main reason for its choice was its tight integration with the React ecosystem. Unlike solutions that run on top of the app, React Router manages navigation state internally, through the familiar useParams hook for reading URL parameters or useNavigate for programmatic navigation. This ensures reactivity: when the address bar changes, components automatically re-render, picking up the new data from the URL.
  * State managment: local state managment
  ### When a developer faces the question of which tool to use for state management in a React application, the decision to use local state management—that is, library-built mechanisms like useState and useReducer—should be deliberate and driven by the specific benefits this approach offers. This isn't just a technical detail, but a strategic decision that impacts the project's architecture, reliability, and development speed.
  ### First and foremost, local state management is chosen for its simplicity and transparency. When state resides within a component or is propagated to the nearest common ancestor, data flow remains intuitive. Any developer reading the code can trace where data comes from and which functions modify it simply by analyzing the component hierarchy and the props passed in. There's no global store magic here, no need to delve into complex architecture to understand why a button changed color. This simplicity directly translates into development speed and ease of debugging, especially in the early stages of a project.
  ### Furthermore, local state provides natural isolation and reusability. A component that manages its own state becomes a self-contained module. You can take such a component and move it to another project or another part of the application, and it will continue to work because all its dependencies are explicitly declared within it or passed in via props. It doesn't require any specific fields to be defined in the global store, and it doesn't create hidden couplings with other parts of the system. This makes code cleaner, more modular, and more reusable.

## Backend:
 * Language: Node.js
  ### The choice of Node.js as a server technology is the foundation of the countless architecture of modern web applications, driven by its unique combination of technical characteristics, cost-effectiveness, and vast community. It's not just another tool, but a paradigm shift in how we approach building scalable and high-load systems.
  ### The fundamental advantage of Node.js lies in its architecture. Unlike traditional servers, which create a separate thread for each connection and consume significant resources, Node.js uses a single-threaded, event-driven model with non-blocking I/O. Imagine an office with a single, ideal manager: instead of personally handling every call and lingering on the line, they instantly accept requests, transfer them to the appropriate specialist, and immediately switch to the next call. Thanks to this, a single Node.js thread can handle tens of thousands of concurrent connections with minimal memory and CPU usage.The fundamental advantage of Node.js lies in its architecture. Unlike traditional servers, which create a separate thread for each connection and consume significant resources, Node.js uses a single-threaded, event-driven model with non-blocking I/O. Imagine an office with a single, ideal manager: instead of personally handling every call and lingering on the line, they instantly accept requests, transfer them to the appropriate specialist, and immediately switch to the next call. Thanks to this, a single Node.js thread can handle tens of thousands of concurrent connections with minimal memory and CPU usage.
  ### The second key factor is the unified language across the entire technology stack. Node.js allows JavaScript to be used not only in the browser but also on the server. This means the development team can be cross-functional: front-end developers easily learn to write server-side logic, and code (for example, data validators or formatting functions) can be reused on both the client and server. This unified language dramatically speeds up development, simplifies codebase maintenance, and reduces training costs for new employees and the product itself.
  * Data base: MySQL
  ### MySQL, as your database management system, has been the benchmark for reliability for countless web applications for decades, and its popularity stems from the perfect balance between power, maturity, and ease of use. It's more than just a data warehouse, but a proven battlefield tool that powers industry giants like Facebook, Twitter, and YouTube.
  ### MySQL's fundamental advantage is its architectural maturity and reliability. Developed for over a quarter century, this database has been tested under the harshest operational conditions. It fully complies with ACID (Atomicity, Consistency, Isolation, Durability) requirements when used with appropriate storage engines like InnoDB, guaranteeing data integrity and transaction predictability. This is critical for any serious business application where data loss or consistency issues are unacceptable.

## Infrastructure
  * Hosting for frontend: Netlify
  ### The choice of Netlify as a platform for deploying and hosting web projects is a decision that underlies the modern approach to web development known as Jamstack. This isn't just hosting, but a fundamental change in how developers interact with infrastructure, driven by its unique combination of simplicity, automation, and built-in capabilities that eliminate the need to manage servers and complex DevOps processes.
  ### Netlify's fundamental advantage is its Git-centric workflow philosophy. Instead of manually uploading files via FTP or setting up complex CI/CD pipelines, developers simply connect a Git repository to the platform, and Netlify handles the rest: automatically building the project, running tests, and publishing it to the global content delivery network. This process is repeated with every new push to the repository, ensuring that the production version of the code is always up-to-date. Furthermore, Netlify automatically generates a unique preview URL for each pull request, allowing designers, managers, and clients to see changes live before they are merged into the main branch.
  ### The second key factor is its inherent focus on performance and global availability. From the moment it's deployed, every Netlify site is automatically distributed via a powerful global CDN (Content Delivery Network), which caches static files on servers around the world. This means a user in Tokyo loads the site from a Tokyo server, while a user in San Francisco loads the site from a San Francisco server, ensuring lightning-fast loading speeds regardless of geography. This performance is achieved without a single line of additional code or complex configuration—it's simply a feature of the platform.
  * Hosting for backend and DB: local host
  ### Choosing a local host as a development and testing environment is not just a technical detail, but a fundamental principle of modern workflow organization that determines the efficiency, security, and speed of software development. This decision is based on common sense and the long-standing practice of developers around the world.
  ### First and foremost, a local host means absolute freedom and independence. When you work on your own computer, you're not dependent on an internet connection, the availability of remote servers, or the stability of cloud providers. You can develop an app on a train, on a plane, or anywhere with an unstable connection. This means your creative and workflow is never interrupted by circumstances beyond your control. You have complete control over the environment and can make any changes without regard to external circumstances.
  ### The second most important factor is the speed and efficiency of iterations. Data exchange between processes within a single computer is orders of magnitude faster than transferring data over a network to a remote server. This means your changes are applied instantly, and the "write code - see results" cycle is reduced to fractions of a second. This speed is crucial for productivity: you can experiment, try different approaches, and quickly find optimal solutions without wasting time waiting.
